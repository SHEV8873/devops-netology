# Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"

|<p>№</p>вопроса|Вопрос|Ответ|
|:-------:|--------|---------|
|1.|Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.|Команда cd является внутренней командой оболочки - «shell builtin» и служит для изменения рабочего каталога. Это связано с тем, что при выполнении таких команд оболочка не создает новый процесс, как в случае с внешними командами, а сама выполняет команду. Иначе, как в случае с внешними командами, при создании нового процесса новый процесс наследует каталог родительского процесса, и команда cd наследовала бы каталог родительского процесса, при этом цель команды - смена рабочего каталога на необходимый являлась бы недостижимой.|
|2.|Какая альтернатива без pipe команде grep <some_string> <some_file> &#124; wc -l ? man grep поможет в ответе на этот вопрос. Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe.|grep <some_string> <some_file> -c|
|3.|Какой процесс с PID `1` является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?|Процесс systemd - подсистема инициализации и управления службами имеет PID 1<p>ps -p 1</p>|
|4.|Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?|<p>$ who</p><p>vagrant  pts/0....</p><p>vagrant  pts/1 ....</p><p>$ ls [OPTION] [FILE] 2>/dev/pts/1</p>|
|5.|Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.|<p>$ echo "#STDIN TEE">teestdin.txt</p><p>$ cat teestdin.txt</p><p>#STDIN TEE</p><p>$ cat teestdout.txt</p><p>cat: teestdout.txt: No such file or directory</p><p>$ tee < teestdin.txt > teestdout.txt</p><p>$ cat teestdout.txt</p>#STDIN TEE|
|6.|Получится ли находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?|<p>Получится</p><p>$ who</p><p>tty7<p>$ tty</p><p>/dev/pts/0</p></p><p>$ echo "Hello, World!" >/dev/tty3</p><p>Для наблюдения данных необходимо переключиться на эмулятор терминала tty3, нажав:</p><p>Ctrl+Alt+F3</p><p>Hello, World!</p><p>$ who</p>tty3|
|7.|Выполните команду `bash 5>&1`. К чему она приведет? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит?|<p>Выполнение `bash 5>&1` приведёт к созданию дескриптора 5 (по пути /proc/$$/fd/5) и перенаправления вывода в файл с дескриптором 5 в файл с дескриптором 1 (stdout)</p><p>Выполнение команды`echo netology > /proc/$$/fd/5` приведёт к следующему:</p><p>стандартный вывод (stdout) команды echo будет перенаправлен в файл с дескриптором 5, расположенному по ссылке /proc/$$/fd/5, которая ссылается туда, куда и стандартный вывод stdout</p><p>таким образом, на экран будет выведено:</p><p>netology<p>точно также как при выполнении команды `echo netology`</p>|
|8.|Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от &#124; на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.|<p>Получится</p><p>Используя ранее созданный дескриптор 5:</p><p>$ ls -l 2>&1 1>&5 &#124; wc -c</p>|
|9.|Что выведет команда `cat /proc/$$/environ`? Как еще можно получить аналогичный по содержанию вывод?|Команда `cat /proc/$$/environ` выведет список переменных среды процесса. Аналогичный по содержанию вывод можно получить командами: env, printenv, export|
|10.|Используя `man`, опишите что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`.|</p>По адресу `/proc/<PID>/cmdline` находится доступный только для чтения файл, содержащий полную командную строку для процесса, если этот процесс не является зомби. В последнем случае в этом файле ничего нет: то есть чтение этого файла вернет 0 символов. Аргументы командной строки отображаются в этом файле как набор строк, разделенных нулевыми байтами ('\0'), с дополнительным нулевым байтом после последней строки. </p><p>По адресу `/proc/<PID>/exe`находится файл, представляющий собой символическую ссылку, содержащую фактический путь к выполняемой команде. Эта символическая ссылка может быть разыменована обычным образом; попытка открыть его откроет исполняемый файл. </p>|
|11.|Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`.|<p>$ grep sse /proc/cpuinfo</p>sse4_2|
|12.|<p>При открытии нового окна терминала и `vagrant ssh` создается новая сессия и выделяется pty. Это можно подтвердить командой `tty`, которая упоминалась в лекции 3.2. Однако:</p><p>vagrant@netology1:~$ ssh localhost 'tty'</p><p>not a tty</p>Почитайте, почему так происходит, и как изменить поведение.|<p>Предполагаю, что для такого соединения с самим собой не требуется выделения pty.</p><p> Это можно изменить, применив флаг -t:</p><p>vagrant@netology1:~$ ssh -t localhost 'tty'</p>|
|13.|Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись `reptyr`. Например, так можно перенести в `screen` процесс, который вы запустили по ошибке в обычной SSH-сессии.|<p>Запускаем процесс: $ (имя процесса)</p><p>Приостанавливаем процесс: CTRL+Z</p><p>Возобновляем процесс в фоновом режиме: $ bg</p><p>Отображаем запущенные в фоновом режиме процессы с указанием их PID: $ jobs -l</p><p>Отвязываем процесс от текущего родителя: $ disown (имя процесса)</p><p>Запускаем новый процесс: $ screen</p><p>Подключаемся к исходному процессу, используя его PID: $ reptyr (PID процусса) (при этом kernel.yama.ptrace_scope должна равняться 0)</p><p>Выходим из screen и закрываем ssh</p><p>Снова подключаемся по ssh и отображаем список всех запущенных сеансов screen: $ screen -r</p><p>Подключаемся к нужному сеансу screen: $ screen -r (PID screen) и наблюдаем исходный процесс</p>|
|14.|sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. Для решения данной проблемы можно использовать конструкцию echo string &#124; sudo tee /root/new_file. Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.|<p>Команда tee считывает stdin, записывает его в stdout и одновременно копирует его в файл или переменную. sudo tee будет работать так как процесс записи в файл /root/new_file будет осуществляться не от имени текущего пользователя, а от пользователя с правами root. Данная конструкция использовалась в предыдущем задании:</p>$ echo 0&#124;sudo tee /proc/sys/kernel/yama/ptrace_scope|



